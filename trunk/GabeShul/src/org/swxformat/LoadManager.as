package org.swxformat{	import flash.events.EventDispatcher;	import flash.events.Event;		import org.swxformat.events.*;			public class LoadManager extends EventDispatcher	{		// Should the class give verbose error and info messages?		public static var verbose:Boolean = true;				private static var instance:LoadManager = null;				private var queue:Array = null;			private var isRunning:Boolean = false;		private var currentExternalAsset:ExternalAsset = null; 				public function LoadManager()		{			echo ("SWX LoadManager INFO: Initialized.");						// Create the load queue			queue = new Array();		}						// Accessor method		public static function getInstance():LoadManager		{					if (instance == null)			{				instance = new LoadManager();			}			return instance;		}				public function cancelAllLoads():void 		{			// Stop loading the current external asset.			currentExternalAsset.removeEventListener(SWXLoadedNotReadyEvent.LOADED_BUT_NOT_READY, loadNextExternalAsset);			currentExternalAsset.removeEventListener(SWXTimeoutEvent.TIMEOUT, loadNextExternalAsset);			currentExternalAsset.removeEventListener(SWXFaultEvent.FAULT, loadNextExternalAsset);			currentExternalAsset.cancel();				// Cancel all external assets in the queue.			var numAssetsInQueue:uint = queue.length;			for (var i:uint = 0; i < numAssetsInQueue; i++)			{				queue[i].cancel();			}				// Empty the queue.			queue = new Array();						// Not running.			isRunning = false;		}						public function load(externalAsset:ExternalAsset):void		{			addToQueue(externalAsset);					}				public function addToQueue(externalAsset:ExternalAsset):void		{			queue.push(externalAsset);				// If the queue is not running, start it.			if (!isRunning) start();		}				//		// Private methods		//				//		// Static methods		//							static private function echo(msg:String):void 		{			if (LoadManager.verbose)			{				trace (msg);			}		}						//		// Instance methods		//					private function start():void		{			isRunning = true;			loadNextExternalAsset();		}				private function loadNextExternalAsset(e:Event = null):void		{			// Clean up handlers on the last external asset			if (currentExternalAsset && !currentExternalAsset.isCancelled)			{				currentExternalAsset.removeEventListener(SWXLoadedNotReadyEvent.LOADED_BUT_NOT_READY, loadNextExternalAsset);				currentExternalAsset.removeEventListener(SWXTimeoutEvent.TIMEOUT, loadNextExternalAsset);				currentExternalAsset.removeEventListener(SWXFaultEvent.FAULT, loadNextExternalAsset);			}						if (queue.length == 0)			{				// Queue is complete				isRunning = false;				dispatchEvent(new SWXLoadManagerCompleteEvent());				return;			}								// Get the next external asset			currentExternalAsset = queue.shift();							currentExternalAsset.addEventListener(SWXLoadedNotReadyEvent.LOADED_BUT_NOT_READY, loadNextExternalAsset);			currentExternalAsset.addEventListener(SWXTimeoutEvent.TIMEOUT, loadNextExternalAsset);			currentExternalAsset.addEventListener(SWXFaultEvent.FAULT, loadNextExternalAsset);			currentExternalAsset.load();						dispatchEvent(new SWXLoadManagerProgressEvent());		}	}	}