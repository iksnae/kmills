package com.wordhunt.view{	import com.wordhunt.control.GameLogic;	import com.wordhunt.model.GameConfig;		import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.events.TimerEvent;	import flash.geom.Point;	import flash.text.TextField;	import flash.text.TextFormat;	import flash.text.TextFormatAlign;	import flash.utils.Timer;	public class BoardView extends Sprite	{								//////////////////////////////////		/////  PRIVATE PROPERTIES		//////////////////////////////////						private var _tiles:Array;		private var _config:GameConfig;		private var _bg:Sprite = new Sprite();		private var _selectionLines:Sprite;		private var _tileHolder:Sprite;		private var _currentLine:Sprite;		private var _listHolder:Sprite		private var _logic:GameLogic;		private var _firstSelected:TileView;		private var _lastSelected:TileView;		private var _corner:Number=10;		private var _lineColor:uint;		private var _strokeColor:uint;		private var _strokeAlpha:int;		private var _lineAlpha:Number;		private var _puzzleSize:int		private var _currentPos:Point;		private var _isDrawing:Boolean;		private var _wordList:Array;		private var _drawTimer:Timer=new Timer(10);		private var _usedWords:Array;		private var _letters:Array		private var _grid:Array=new Array();				//////////////////////////////		////  CONSTRUCTOR		//////////////////////////////				public function BoardView(conf:GameConfig)		{			super();			_config=conf;			_logic = GameLogic.getInstance()						build();				}		 public function get usedWords():Array{            return _usedWords;        }														//////////////////////////////		////  PUBLIC METHODS		//////////////////////////////				/**		 * this method builds the board view and sets initial state 		 * @param conf		 * 		 */				public function build():void{					_corner = config.tileSize						_currentLine= new Sprite();			_selectionLines=new Sprite()			_listHolder=new Sprite()						_lineColor  	= _config.lineFillColor;			_lineAlpha  	= _config.lineFillAlpha;			_strokeColor 	= _config.lineStrokeColor;			_strokeAlpha	= _config.lineStrokeAlpha;						_tileHolder	= new Sprite()			_currentLine.mouseEnabled=false;			_currentLine.mouseChildren=false;			_selectionLines.mouseEnabled=false;			_selectionLines.mouseChildren=false;			_tiles = new Array()									_letters = placeLetters();						_drawTimer.addEventListener(TimerEvent.TIMER,onDrawTimer);			//graphics.beginFill(0x000000,1)			//graphics.drawRect(0,0,2400, 1200);					for(var column:int=0; column<config.gridWidth;column++){				for(var row:int=0; row< config.gridHeight;row++){					var tile:TileView = new TileView(config);					tile.name 	= 'Col'+column+'Row'+row;				//	trace(tile+': '+tile.name )					tile.x 		= column * config.tileSize;					tile.y 		= row	* config.tileSize;													tile.col	= column;					tile.row 	= row;					tile.char 	= _letters[row][column];							tile.addEventListener(MouseEvent.MOUSE_DOWN, pressHandler)					tile.addEventListener(MouseEvent.MOUSE_UP, releaseHandler)					_tileHolder.addChild(tile)										_tiles.push(tile);				}			}			//_bg.graphics.lineStyle(1,config.gameCharacterColor)			_bg.graphics.beginFill(config.gameBackgroundColor)			_bg.graphics.drawRect(0,0,_tileHolder.width,_tileHolder.height)												_listHolder.x = ((_config.gridWidth+1)*_config.tileSize)+4;			_listHolder.y =160			_listHolder.graphics.beginFill(0x344a33)			_listHolder.graphics.drawRect(0, 0, 250,320);						addChild(_bg)    			addChild(_selectionLines)			addChild(_currentLine)			addChild(_tileHolder)			addChild(_listHolder)						_logic.gameView = this;			_logic.build(_config.words)			dispatchEvent(new Event('ready'))			var ofx:int = 0			var ofy:int = 0			var cnt:int = 0			trace('usedWords: '+usedWords)			for(var i:int=0;i<usedWords.length;i++) {                var newWord:TextField = new TextField();                newWord.defaultTextFormat = new TextFormat("Arial",14,0x000000,true,false,false,null,null,TextFormatAlign.LEFT);            //    newWord.x = 600;                newWord.y = ofy*16                newWord.x = ofx                newWord.width = 140;                                newWord.text = usedWords[i];                newWord.selectable = false;                _listHolder.addChild(newWord);                cnt++;                ofy++;                if(cnt==19){                	cnt=0;                	ofy=0;                	ofx+=135;                }                            }          					}						////////////////////////		///  PUBLIC GETTERS		////////////////////////				public function get lastSelection():TileView{			return _lastSelected		}		public function get firstSelection():TileView{			return _firstSelected		}		public function get drawView():Sprite{			return _currentLine		}		public function get listView():Sprite{            return _listHolder        }		public function get logic():GameLogic{			return _logic		}		public function get tileView():Sprite{			return _tileHolder		}		public function get selectionView():Sprite{			return _selectionLines		}		public function get config():GameConfig{			return _config;		}		public function get tiles():Array{			return _tiles		}		public function get grid():Array{			return _grid;		}								//////////////////////////////		///  PRIVATE METHODS		//////////////////////////////				private function drawLine():void{			_logic.drawSelection(_logic.calcStraightLine())					}		private function drawDiagLine():void{			_logic.drawSelection(_logic.calcDiagnoleLine())		}		private function startLineDraw():void{			_drawTimer.start()		}		private function stopLineDraw():void{            _drawTimer.stop()            _currentLine.graphics.clear()            deselectAll()        }		private function onDrawTimer(e:TimerEvent):void{			var startingPt:Point = calcCenter(_firstSelected);			_logic.drawLine(calcCenter(_firstSelected))		}		public function calcCenter(targ:TileView):Point{			return new Point( targ.x+targ.center.x,  targ.y+targ.center.y )		}		private function overHandler(e:MouseEvent):void{			_currentPos= new Point(e.target.col,e.target.row);		}		private function deselectAll():void{			for ( var i:int=0;i<_tiles.length;i++){			     _tiles[i].selected=false;			}		}		////////////////////////////////// 		///  MOUSE EVENT HANDLERS 		//////////////////////////////////				/**		 * mouse down handler.		 * - stores firstSelection		 * - sets current tile "selected" value to true		 * - set other tiles' "selected" value to false		 * - calls startLineDraw() method		 * @param e		 * @see startLineDraw()		 * 		 */			private function pressHandler(e:MouseEvent):void{					_firstSelected = e.currentTarget as TileView;			for(var i:int=0;i<_tiles.length; i++){				var targ:TileView = e.currentTarget as TileView;				if(_tiles[i] == targ){					_tiles[i].selected=true				}else{					_tiles[i].selected=false				}			}			startLineDraw()		}				/**		 * mouse up handler.		 * - checks if first/last selections are: "in same row", "in same column" or "at 45 degree angle"		 * - calls stopLineDraw() method		 * @param e		 * @see stopLineDraw()		 * 		 */			private function releaseHandler(e:MouseEvent):void{			_lastSelected = e.currentTarget as TileView;			if(!_logic.isSameTile()){				var word:String = _logic.getSelectedWord();				var wordFound:Boolean = _logic.checkWord(word);								if(_logic.inSameRow()       && wordFound) 	drawLine();				if(_logic.inSameColumn()    && wordFound) 	drawLine();				if(_logic.inDiagnol()       && wordFound) 	drawDiagLine();											}			stopLineDraw()		}		public function get puzzleSize():Number{            return _config.gridWidth;        }        public function placeLetters():Array {                        // create empty grid            var letters:Array = new Array();            for(var x:int=0;x<puzzleSize;x++) {                letters[x] = new Array();                for(var y:int=0;y<puzzleSize;y++) {                    letters[x][y] = "*";                }            }            // make copy of word list            var wordListCopy:Array = config.rawWords.split(",");            _usedWords = new Array();                        // make 1000 attempts to add words            var repeatTimes:int = 1000;            repeatLoop:while (wordListCopy.length > 0) {                if (repeatTimes-- <= 0) break;                                // pick a random word, location and direction                var wordNum:int = Math.floor(Math.random()*wordListCopy.length);                var word:String = wordListCopy[wordNum].toUpperCase();                x = Math.floor(Math.random()*puzzleSize);                y = Math.floor(Math.random()*puzzleSize);                var dx:int = Math.floor(Math.random()*3)-1;                var dy:int = Math.floor(Math.random()*3)-1;                if ((dx == 0) && (dy == 0)) continue repeatLoop;                                // check each spot in grid to see if word fits                letterLoop:for (var j:int=0;j<word.length;j++) {                    if ((x+dx*j < 0) || (y+dy*j < 0) || (x+dx*j >= puzzleSize) || (y+dy*j >= puzzleSize)) continue repeatLoop;                    var thisLetter:String = letters[x+dx*j][y+dy*j];                    if ((thisLetter != "*") && (thisLetter != word.charAt(j))) continue repeatLoop;                }                                // insert word into grid                insertLoop:for (j=0;j<word.length;j++) {                    letters[x+dx*j][y+dy*j] = word.charAt(j);                }                                // remove word from list                wordListCopy.splice(wordNum,1);                usedWords.push(word);            }                        // fill rest of grid with random letters            for(x=0;x<puzzleSize;x++) {                for(y=0;y<puzzleSize;y++) {                    if (letters[x][y] == "*") {                        letters[x][y] = String.fromCharCode(65+Math.floor(Math.random()*26));                    }                }            }            return letters;        }					}}