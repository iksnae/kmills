package org.swxformat{	import flash.events.EventDispatcher;	import flash.events.Event;	import flash.events.HTTPStatusEvent;	import flash.events.IOErrorEvent;	import flash.events.SecurityErrorEvent;	import flash.events.ProgressEvent;	import flash.events.TimerEvent;	import flash.display.Loader;	import flash.net.URLLoader;	import flash.net.URLRequest;	import flash.net.URLVariables;	import flash.net.URLRequestMethod;	import flash.net.URLLoaderDataFormat;		import flash.utils.*;	import org.swxformat.events.*;		public class ExternalAsset extends EventDispatcher	{				private var _encoding:String = ExternalAsset.POST;				private var _gateway:String = null;		private var _data:Object = null;		private var _timeout:Number = 30; // in seconds				private var _loaded:Boolean = false;		private var _cancelled:Boolean = false;		private var _loading:Boolean = false;				private var _loader:Loader = null;		private var _urlLoader:URLLoader = null;		private var timeoutTimer:Timer;				// Should the class give verbose error and info messages?		public static var verbose:Boolean = true;		public static var POST:String = "POST";		public static var GET:String = "GET";				function ExternalAsset ()		{		}					/** Property setters **/		public function set gateway (_gateway:String):void		{			this._gateway = _gateway;		}		public function set encoding (_encoding:String):void		{			if (_encoding != ExternalAsset.POST && _encoding != ExternalAsset.GET)			{				echo ("Warning: Encoding must be either POST or GET. Keeping current setting ("+this._encoding+")");			}			else			{				this._encoding = _encoding;			}		}				public function set timeout (_timeout:Number):void		{			if (_timeout > 0)			{				this._timeout = _timeout;			}		}				public function set data (_data:Object):void		{			this._data = _data;		}								/** Status getters **/		public function get isLoaded():Boolean		{			return _loaded;		}				public function get isCancelled():Boolean		{			return _cancelled;		}				public function get isLoading():Boolean		{			return _loading;		}				/** Load **/		public function load():void		{			echo("ExternalAsset.load() info: Sending data using " + _encoding + " encoding.");							// Prepare request			var request:URLRequest = new URLRequest(_gateway);						// Copy any data to be sent to the server into the holder movie clip			var parameters:URLVariables = new URLVariables();						for (var i in _data)			{				parameters[i] = _data[i];			}			request.data = parameters;			request.method = _encoding;						// Create URL Loader			_urlLoader = new URLLoader();			_urlLoader.dataFormat = URLLoaderDataFormat.BINARY;			_urlLoader.addEventListener(ProgressEvent.PROGRESS,onProgress);			_urlLoader.addEventListener(Event.COMPLETE,onLoadComplete);			_urlLoader.addEventListener(IOErrorEvent.IO_ERROR, onIOError);			_urlLoader.addEventListener(SecurityErrorEvent.SECURITY_ERROR, onSecurityError);						// Show HTTP Status 			_urlLoader.addEventListener(HTTPStatusEvent.HTTP_STATUS,onHttpStatus);						// Set flag			_loading = true;				_urlLoader.load(request);						// Timeout			timeoutTimer = new Timer(_timeout * 1000,1);			timeoutTimer.addEventListener(TimerEvent.TIMER,onTimeout);					}				public function cancel():Boolean		{			if (_loaded)			{				echo("Warning: Cannot cancel loading clip since it has already loaded: " + _gateway);				return false;			}			else			{				echo("Cancelling load");				if (timeoutTimer)					timeoutTimer.stop();								_cancelled = true;				_loading = false;				return true;			}		}				//		// Private methods		//				//		// Static methods		//						static private function echo(msg:String):void		{			if (ExternalAsset.verbose)			{				trace (msg);			}		}				//		// Instance methods		//						private function onHttpStatus(e:HTTPStatusEvent):void		{			echo ("ExternalAsset HttpStatus: "+e.status);		}				private function onProgress(e:ProgressEvent):void		{			echo ("ExternalAsset Progress("+e.bytesLoaded+", "+e.bytesTotal+")");			dispatchEvent(new SWXProgressEvent(e.bytesLoaded, e.bytesTotal ));		}				private function onIOError(e:IOErrorEvent):void		{			timeoutTimer.stop();			dispatchEvent(new SWXFaultEvent({error:true, code:-1, message:'IO Error: Unable to load from url '+_gateway+'.'})); 		}				private function onSecurityError(e:IOErrorEvent):void		{			timeoutTimer.stop();			dispatchEvent(new SWXFaultEvent({error:true, code:-1, message:'Security Error: Attempting to load data from a server outside the security sandbox.'})); 		}				private function onTimeout(e:TimerEvent):void		{			echo("ExternalAsset timeout");			_urlLoader.close();			_urlLoader = null;			dispatchEvent(new SWXTimeoutEvent());		}						private function onLoadComplete(e:Event):void		{						echo("ExternalAsset loaded");						timeoutTimer.stop();						_loaded = true;			_loading = false;						// Dispatch an event now in case someone needs it.			dispatchEvent(new SWXLoadedNotReadyEvent());						// try to parse result			try			{				_loader = new Loader();				_loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, onIOError);				_loader.contentLoaderInfo.addEventListener(Event.INIT, onMovieReady);				_loader.loadBytes(_urlLoader.data);			}			catch(e:Error)			{				// unable to parse				dispatchEvent(new SWXFaultEvent({error:true, code:-1, message:'Unable to parse content: '+e.message})); 			}									}				private function onMovieReady(e:Event):void		{			try			{				var clip = _loader.content;				if ('error' in clip.result)				{					// An error was returned, raise a FAULT event. 					dispatchEvent(new SWXFaultEvent(clip.result));				}				else				{					// Result returned, raise a RESULT event.					dispatchEvent(new SWXResultEvent(clip.result)); 				}			}			catch(e:Error)			{				// Invalid content, raise a FAULT event. 				dispatchEvent(new SWXFaultEvent({error:true, code:-1, message:'Unable to parse content: '+e.message})); 			}		}					}			}